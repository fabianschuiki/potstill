#!/usr/bin/env python3
# Copyright (c) 2016 Fabian Schuiki
import sys, os, argparse, itertools
import potstill.macro
import potstill.timing
import potstill.layout


# Parse the command line arguments.
parser = argparse.ArgumentParser(prog="potstill make-lib", description="Generate the LIB view of a memory macro.")
parser.add_argument("num_addr", metavar="NADDR", type=int, help="number of address lines")
parser.add_argument("num_bits", metavar="NBITS", type=int, help="number of bits")
args = parser.parse_args()


# Calculate the timing.
macond = potstill.macro.MacroConditions(args.num_addr, args.num_bits)
timing = potstill.timing.Timing(macond)
layout = potstill.layout.Layout(args.num_addr, args.num_bits)


# Generate and output the LIB file.
def gather_axes(data, scale, axes, fixes=[]):
	axis = axes[0]
	if len(axes) == 1:
		keys = [",".join(fixes+[axis[0]+"="+stop]) for stop in axis[3]]
		return [", ".join(["%f" % (data[k]*scale) for k in keys])]
	else:
		values = list()
		for stop in axis[3]:
			values += gather_axes(data, axis[2], axes[1:], fixes+[axis[0]+"="+stop])
	return values


class LibWriter(object):
	def __init__(self):
		super(LibWriter, self).__init__()
		self.lines = list()
		self.level = 0
		self.prefix = ""

	def comment(self, *lines):
		if len(lines) == 1:
			self.lines.append(self.prefix + "/* " + lines[0] + " */")
		elif len(lines) > 1:
			self.lines.append(self.prefix + "/*")
			self.lines += [self.prefix + " " + ("* "+(l or "")).strip() for l in lines]
			self.lines.append(self.prefix + " */")

	def skip(self, num=1):
		self.lines += itertools.repeat("", num)

	def simple(self, name, arg):
		self.lines.append(self.prefix + name + " : " + arg + " ;")

	def complex(self, name, *args, suffix=";"):
		self.lines.append(self.prefix + name + "(" + ", ".join(args) + ")" + (suffix or ""))

	def pushgrp(self, *args):
		self.complex(*args, suffix=None)
		self.level += 1
		self.prefix = "  "*self.level

	def popgrp(self):
		assert(self.level > 0)
		self.level -= 1
		self.prefix = "  "*self.level
		self.lines.append(self.prefix + "}")

	def pushpin(self, name, clock=False, dir="input", cap=None, keyword="pin"):
		self.pushgrp(keyword, name)
		self.simple("direction", dir)
		if clock:
			self.simple("clock", "true")
		if cap is not None:
			self.simple("capacitance", "%f" % (cap*1e15))

	def intpwr(self, rise, fall, template, when=None, **kwargs):
		self.pushgrp("internal_power")
		if when is not None:
			self.simple("when", '"'+when+'"')
		for (k,v) in kwargs.items():
			self.simple(k,v)
		if rise is not None:
			self.table("rise_power", template, rise, 1e15)
		if rise is not None:
			self.table("fall_power", template, fall, 1e15)
		self.popgrp()

	def timing(self, rise, fall, template, **kwargs):
		self.pushgrp("timing")
		for (k,v) in kwargs.items():
			self.simple(k,v)
		if rise is not None:
			self.table("rise_constraint", template, rise, 1e12)
		if rise is not None:
			self.table("fall_constraint", template, fall, 1e12)
		self.popgrp()

	def template(self, name, template):
		self.pushgrp(name, template.name)
		for (i, (_, var, _, _)) in enumerate(template.axes):
			self.simple("variable_%d"%(i+1), var)
		for (i, (_, _, scale, stops)) in enumerate(template.axes):
			self.complex("index_%d"%(i+1), '"'+", ".join(["%f" % (float(s)*scale) for s in stops])+'"')
		self.popgrp()

	def table(self, name, template, data, scale):
		self.pushgrp(name, template.name)
		self.values(gather_axes(data, scale, template.axes))
		self.popgrp()

	def values(self, values):
		for i in range(len(values)):
			prefix = "values(\"" if i == 0 else "       \""
			suffix = "\");" if i == len(values)-1 else "\", \\"
			self.lines.append(self.prefix + prefix + values[i] + suffix)

	def collect(self):
		return "\n".join(self.lines)+"\n"


class TableTemplate(object):
	def __init__(self, name, *axes):
		super(TableTemplate, self).__init__()
		self.name = name
		self.axes = list(axes)


def make_lib(timing, layout):
	opcond = "vdd=%g,temp=%g" % (timing.macond.vdd, timing.macond.temp)
	figures = timing.figures[opcond]

	wr = LibWriter()
	wr.comment(
		"Standard Cell Based Memory",
		"%d words, %d bits @ at %gV, %gÂ°C" % (timing.macond.num_words, timing.macond.num_bits, timing.macond.vdd, timing.macond.temp),
		None,
		"Automatically generated by Potstill"
	)
	wr.pushgrp("library", timing.name)

	# Write the introductory information.
	wr.simple("delay_model", "table_lookup")
	wr.simple("nom_process", "1")
	wr.simple("nom_temperature", "%.0f" % timing.macond.temp)
	wr.simple("nom_voltage", "%.2f" % timing.macond.vdd)
	wr.skip()

	# Write the units.
	wr.comment("Units")
	wr.simple("time_unit", "1ps")
	wr.simple("voltage_unit", "1V")
	wr.simple("current_unit", "1mA")
	wr.simple("pulling_resistance_unit", "1kohm")
	wr.simple("leakage_power_unit", "1nW")
	wr.complex("capacitive_load_unit", "1", "fF")
	wr.skip()

	# Write the threshold points.
	wr.comment("Slew and Delay Threshold Points")
	wr.simple("slew_derate_from_library", "1")
	wr.simple("slew_lower_threshold_pct_rise", "10")
	wr.simple("slew_upper_threshold_pct_rise", "90")
	wr.simple("slew_lower_threshold_pct_fall", "10")
	wr.simple("slew_upper_threshold_pct_fall", "90")
	wr.simple("input_threshold_pct_fall", "50")
	wr.simple("output_threshold_pct_fall", "50")
	wr.simple("input_threshold_pct_rise", "50")
	wr.simple("output_threshold_pct_rise", "50")
	wr.skip()

	# Declare the bus types used for this memory.
	wr.comment("Bus Types")
	wr.pushgrp("type", "A%d" % timing.macond.num_addr)
	wr.simple("base_type", "array")
	wr.simple("data_type", "bit")
	wr.simple("bit_width", str(timing.macond.num_addr))
	wr.simple("bit_from", str(timing.macond.num_addr-1))
	wr.simple("bit_to", "0")
	wr.simple("downto", "true")
	wr.popgrp()
	wr.pushgrp("type", "D%d" % timing.macond.num_bits)
	wr.simple("base_type", "array")
	wr.simple("data_type", "bit")
	wr.simple("bit_width", str(timing.macond.num_bits))
	wr.simple("bit_from", str(timing.macond.num_bits-1))
	wr.simple("bit_to", "0")
	wr.simple("downto", "true")
	wr.popgrp()
	wr.skip()

	# Declare the various lookup tables.
	tbl_energy_itran = TableTemplate("energy_vs_itran",
		("tslew", "input_net_transition", 1e12, ["10e-12", "50e-12", "200e-12"]),
	)
	tbl_energy_itran_ocap = TableTemplate("energy_vs_itran_ocap",
		("tslew", "input_net_transition", 1e12, ["10e-12", "50e-12", "200e-12"]),
		("cload", "total_output_net_capacitance", 1e15, ["1e-15", "10e-15", "50e-15"]),
	)
	tbl_timing_itran = TableTemplate("timing_vs_itran",
		("tslew", "input_net_transition", 1e12, ["10e-12", "50e-12", "200e-12"]),
	)
	tbl_timing_ritran_citran = TableTemplate("timing_vs_ritran_citran",
		("tslewck", "related_pin_transition", 1e12, ["10e-12", "50e-12", "200e-12"]),
		("tslewpin", "input_net_transition", 1e12, ["10e-12", "50e-12", "200e-12"]),
	)
	tbl_timing_itran_ocap = TableTemplate("timing_vs_itran_ocap",
		("tslew", "input_net_transition", 1e12, ["10e-12", "50e-12", "200e-12"]),
		("cload", "total_output_net_capacitance", 1e15, ["1e-15", "10e-15", "50e-15"]),
	)

	wr.comment("Lookup Table Templates")
	wr.template("power_lut_template", tbl_energy_itran)
	wr.template("power_lut_template", tbl_energy_itran_ocap)
	wr.template("lu_table_template", tbl_timing_itran)
	wr.template("lu_table_template", tbl_timing_ritran_citran)
	wr.template("lu_table_template", tbl_timing_itran_ocap)
	wr.skip()

	# Write the cell.
	wr.comment("Memory Macro")
	wr.pushgrp("cell", timing.macond.name)
	wr.simple("dont_touch", "true")
	wr.simple("interface_timing", "true")
	wr.simple("area", "%f" % (layout.size.x*1e6 * layout.size.y*1e6))
	wr.simple("cell_leakage_power", "%f" % (figures.one("P_leak")*1e9))
	wr.skip()


	# Write the clock pin.
	wr.pushpin("CK", clock=True, cap=figures.one("C_CK"))
	for pwr in [
		("Idle", "idle", "!RE&!WE"),
		("Read", "read", "RE&!WE"),
		("Write", "write", "!RE&WE"),
		("Read+Write", "rw", "RE&WE"),
	]:
		wr.skip()
		wr.comment(pwr[0]+" Power")
		wr.intpwr(
			figures.all("E_%s_rise"%pwr[1]),
			figures.all("E_%s_fall"%pwr[1]),
			tbl_energy_itran,
			when=pwr[2]
		)
	wr.popgrp()
	wr.skip()


	# Write the RE and WE pins.
	for name in ["RE","WE"]:
		wr.pushpin(name, cap=figures.one("C_"+name))
		wr.skip()
		wr.intpwr(figures.all("E_%s_rise"%name), figures.all("E_%s_fall"%name), tbl_energy_itran)

		wr.skip()
		wr.comment("Setup Condition")
		wr.timing(figures.all("Tsu_%s_rise"%name), figures.all("Tsu_%s_fall"%name), tbl_timing_ritran_citran, related_pin="CK", timing_type="setup_rising", sdf_edges="both_edges")

		wr.skip()
		wr.comment("Hold Condition")
		wr.timing(figures.all("Tho_%s_rise"%name), figures.all("Tho_%s_fall"%name), tbl_timing_ritran_citran, related_pin="CK", timing_type="hold_rising", sdf_edges="both_edges")

		wr.popgrp()
		wr.skip()


	# Write the RA, WA, and WD busses.
	for (name, bus_type, char_name) in [
		("RA", "A%d" % timing.macond.num_addr, "RA0"),
		("WA", "A%d" % timing.macond.num_addr, "WA0"),
		("WD", "D%d" % timing.macond.num_bits, "WD0")
	]:
		wr.pushpin(name, cap=figures.one("C_"+char_name), keyword="bus")
		wr.simple("bus_type", bus_type)
		wr.skip()
		wr.intpwr(figures.all("E_%s_rise"%char_name), figures.all("E_%s_fall"%char_name), tbl_energy_itran)

		wr.skip()
		wr.comment("Setup Condition")
		wr.timing(figures.all("Tsu_%s_rise"%name), figures.all("Tsu_%s_fall"%name), tbl_timing_ritran_citran, related_pin="CK", timing_type="setup_rising", sdf_edges="both_edges")

		wr.skip()
		wr.comment("Hold Condition")
		wr.timing(figures.all("Tho_%s_rise"%name), figures.all("Tho_%s_fall"%name), tbl_timing_ritran_citran, related_pin="CK", timing_type="hold_rising", sdf_edges="both_edges")

		wr.popgrp()
		wr.skip()


	# Write the RD bus.
	wr.pushpin("RD", keyword="bus", dir="output")
	wr.simple("bus_type", bus_type)
	wr.skip()
	wr.intpwr(figures.all("E_RD0_rise"), figures.all("E_RD0_fall"), tbl_energy_itran_ocap, related_pin="CK")
	wr.skip()
	wr.comment("Propagation Delay")
	wr.pushgrp("timing")
	wr.simple("related_pin", "CK")
	wr.simple("timing_type", "rising_edge")
	for (name, fig_name) in [
		("cell_rise", "Tpd_RD_rise"),
		("cell_fall", "Tpd_RD_fall"),
		("rise_transition", "Ttran_RD_rise"),
		("fall_transition", "Ttran_RD_fall"),
	]:
		data = figures.all(fig_name)
		if data is not None:
			wr.table(name, tbl_timing_itran_ocap, data, 1e12)
	wr.popgrp()

	wr.popgrp()
	wr.skip()

	# Wrap up the cell and close the library.
	wr.popgrp()
	wr.popgrp()
	return wr.collect()

sys.stdout.write(make_lib(timing, layout))
