#!/usr/bin/env python3
# Copyright (c) 2016 Fabian Schuiki
import sys, os, argparse, itertools
sys.path.insert(0, sys.path[0]+"/..")
import potstill.layout

# Parse the command line arguments.
parser = argparse.ArgumentParser(prog="potstill make-lef", description="Generate the LEF view of a memory macro.")
parser.add_argument("num_addr", metavar="NADDR", type=int, help="number of address lines")
parser.add_argument("num_bits", metavar="NBITS", type=int, help="number of bits")
args = parser.parse_args()

# Generate the layout for the macro.
layout = potstill.layout.Layout(args.num_addr, args.num_bits)

# Generate and output the LEF file.
class LefWriter(object):
	def __init__(self):
		super(LefWriter, self).__init__()
		self.lines = list()
		self.level = 0
		self.prefix = ""

	def comment(self, *lines):
		self.lines += [self.prefix + ("# "+(l or "")).strip() for l in lines]

	def add(self, *args, suffix=" ;"):
		self.lines.append(self.prefix + " ".join(args)+(suffix or ""))

	def skip(self, num=1):
		self.lines += itertools.repeat("", num)

	def pushgrp(self, *args):
		self.add(*args, suffix=None)
		self.level += 1
		self.prefix = "  "*self.level

	def popgrp(self, *args):
		assert(self.level > 0)
		self.level -= 1
		self.prefix = "  "*self.level
		self.add(*args, suffix=None)

	def collect(self):
		return "\n".join(self.lines)+"\n"


class ObstructionSet(object):
	def __init__(self):
		super(ObstructionSet, self).__init__()
		self.layers = dict()

	def add_channel(self, layer, stretch, channel):
		if layer not in self.layers:
			stretches = dict()
			self.layers[layer] = stretches
		else:
			stretches = self.layers[layer]
		if stretch not in stretches:
			stretches[stretch] = set([channel])
		else:
			stretches[stretch].add(channel)


def add_bit_vchannel(obs, layout, layer, stretch, channel):
	for i in range(layout.num_bits_left):
		obs.add_channel(layer, stretch, (i+1) * layout.column_width_trk - channel - 1)
	for i in range(layout.num_bits_right):
		obs.add_channel(layer, stretch, layout.column_right_trk + i * layout.column_width_trk + channel)


# Generates a sequence of integer intervals from an ordered list of integers.
# E.g. intervals([1,2,3,6,8,9]) -> [(1,3),(6,6),(8,9)]
def intervals(values):
	it = iter(values)
	first = next(it)
	last = first
	for i in it:
		if i > last+1:
			yield (first, last)
			first = i
			last = first
		else:
			last = i
	yield (first, last)


def make_lef(layout):
	wr = LefWriter()
	wr.comment(
		None,
		"Standard Cell Based Memory",
		"%d words, %d bits" % (layout.num_words, layout.num_bits),
		None,
		"Automatically generated by Potstill",
		None
	)
	wr.skip()

	# Generate the prelude.
	wr.add("VERSION 5.5")
	wr.add("NAMESCASESENSITIVE ON")
	wr.add("BUSBITCHARS \"[]\"")
	wr.add("DIVIDERCHAR \"/\"")
	wr.skip()

	# Open the macro group.
	wr.pushgrp("MACRO", layout.name)
	wr.add("CLASS CORE")
	wr.add("FOREIGN", layout.name, "0 0")
	wr.add("ORIGIN 0 0")
	wr.add("SIZE", "%g" % (layout.size.x*1e6), "BY", "%g" % (layout.size.y*1e6))
	wr.add("SYMMETRY X Y")
	wr.add("SITE CORE")
	wr.skip()

	# Generate the pin statements.
	for p in layout.pins():
		wr.pushgrp("PIN", p.name)
		wr.add("DIRECTION", p.dir)
		wr.add("USE", p.use)
		if p.shape is not None:
			wr.add("SHAPE", p.shape)
		wr.pushgrp("PORT")
		wr.add("LAYER", p.layer)
		for (ra, rb) in p.rects():
			wr.add("RECT %g %g %g %g" % (ra.x*1e6, ra.y*1e6, rb.x*1e6, rb.y*1e6))
		wr.popgrp("END")
		if p.dir == "INPUT":
			wr.add("ANTENNAMODEL OXIDE1")
			wr.add("ANTENNAGATEAREA 0.0180")
		wr.popgrp("END", p.name)
		wr.skip()

	wr.pushgrp("PIN VDD")
	wr.add("DIRECTION INOUT")
	wr.add("USE POWER")
	wr.add("SHAPE ABUTMENT")
	wr.pushgrp("PORT")
	wr.add("LAYER ME1")
	wr.add("RECT ITERATE 0 1.65 %g 1.95 DO 1 BY %d STEP 0 %g" % (layout.size.x*1e6, layout.num_words/2+1, layout.row_height*2e6))
	wr.popgrp("END")
	wr.popgrp("END VDD")
	wr.skip()

	wr.pushgrp("PIN VSS")
	wr.add("DIRECTION INOUT")
	wr.add("USE GROUND")
	wr.add("SHAPE ABUTMENT")
	wr.pushgrp("PORT")
	wr.add("LAYER ME1")
	wr.add("RECT ITERATE 0 -0.15 %g 0.15 DO 1 BY %d STEP 0 %g" % (layout.size.x*1e6, layout.num_words/2+1, layout.row_height*2e6))
	wr.popgrp("END")
	wr.popgrp("END VSS")
	wr.skip()

	# Calculate the set of obstructed channels.
	obs = ObstructionSet()
	obs_cfg = layout.config["obstructed-channels"]
	vstretch = (0.05, (layout.num_words+1) * layout.row_height * 1e6 - 0.05)
	hstretch = (0.05, layout.size.x * 1e6 - 0.05)

	if "bit" in obs_cfg:
		bit_cfg = obs_cfg["bit"]

		if "vertical" in bit_cfg:
			for (layer, channels) in bit_cfg["vertical"].items():
				for ch in channels:
					add_bit_vchannel(obs, layout, layer, vstretch, ch)

		if "horizontal" in bit_cfg:
			for (layer, channels) in bit_cfg["horizontal"].items():
				for i in range(int(layout.num_words/2)):
					for ch in channels:
						obs.add_channel(layer, hstretch, i*layout.row_height_trk*2 + ch)

	if "bitarray" in obs_cfg:
		for (num_words, channels) in obs_cfg["bitarray"].items():
			if num_words <= layout.num_words:
				for ch in channels:
					add_bit_vchannel(obs, layout, "ME2", vstretch, ch)

	if "regwd" in obs_cfg:
		for (layer, channels) in obs_cfg["regwd"].items():
			for ch in channels:
				obs.add_channel(layer, hstretch, layout.regwd_y_trk + ch)

	# Generate the obstruction statements.
	wr.pushgrp("OBS")
	wr.add("LAYER ME1")
	wr.add("RECT 0 -0.15 %g %g" % (layout.size.x*1e6, layout.size.y*1e6+0.15))
	for (layer, stretches) in obs.layers.items():
		wr.skip()
		wr.add("LAYER", layer)
		chdir = {
			"ME2": "V",
			"ME3": "H",
		}[layer]
		for ((la,lb), channels) in stretches.items():
			for i in intervals(sorted(channels)):
				if chdir == "H":
					x0 = la
					x1 = lb
					y0 = (i[0]-0.25) * layout.grid * 1e6
					y1 = y0 + 0.1
				elif chdir == "V":
					x0 = (i[0]+0.25) * layout.grid * 1e6
					x1 = x0 + 0.1
					y0 = la
					y1 = lb
				else:
					assert(False)
				wr.add("RECT %g %g %g %g" % (x0,y0,x1,y1))
	wr.popgrp("END")

	# Close the macro group.
	wr.popgrp("END", layout.name)
	wr.skip()

	wr.add("END LIBRARY", suffix=None)
	return wr.collect()

sys.stdout.write(make_lef(layout))
