#!/usr/bin/env python3
# Copyright (c) 2016 Fabian Schuiki

import sys
import math
import argparse

BASE = sys.path[0]


def makeNetlist(size, bits):
	lines = list()
	lines.append(".SUBCKT PS%dX%d CK RE %s %s WE %s %s VDD VSS" % (
		2**size, bits,
		" ".join(["RA%d" % i for i in range(size)]),
		" ".join(["RD%d" % i for i in range(bits)]),
		" ".join(["WA%d" % i for i in range(size)]),
		" ".join(["WD%d" % i for i in range(bits)]),
	))

	netsRA = " ".join(["nRA%d" % i for i in range(size)])
	netsWA = " ".join(["WA%d" % i for i in range(size)])
	netsSGPGN = " ".join(["nS%d nGP%d nGN%d" % (i,i,i) for i in range(2**size)])

	# Add the clock buffer that provides the root CKP and CKN signals.
	lines.append("XI0 CK nCKN INV wp=660e-9 wn=480e-9")
	lines.append("XI1 nCKN nCKP INV wp=660e-9 wn=480e-9")

	# Instantiate the two global clock gates.
	lines.append("XWCKG WE nCKP nCKN nWCKP nWCKN CKG")
	lines.append("XRCKG RE nCKP nCKN nRCKP nRCKN CKG")

	# Instantiate the address decoder.
	lines.append("XAD nWCKP nWCKN %s %s %s VDD VSS PSAD%d" % (
		netsRA, netsWA, netsSGPGN, 2**size
	))

	# Instantiate the write data registers.
	for i in range(bits):
		lines.append("XWDREG%d WD%d nWCKP nWCKN nWD%d i%d VDD VSS DFCKPNQPN" % (
			i, i, i, i
		))

	# Instantiate the read address registers.
	for i in range(bits):
		lines.append("XRAREG%d RA%d nRCKP nRCKN nRA%d i%d VDD VSS DFCKPNQPN" % (
			i, i, i, i
		))

	# Instantiate the bit arrays.
	for i in range(bits):
		lines.append("XBA%d nWD%d %s RD%d VDD VSS PSBA%d" % (
			i, i, netsSGPGN, i, 2**size
		))

	lines.append(".ENDS")

	with open("%s/umc65/netlists/components.cir" % BASE, "r") as f:
		netlistPrefix = f.read()

	return "\n\n".join([
		netlistPrefix,
		makeNetlistForAD(size),
		makeNetlistForBA(size),
		"\n".join(lines)
	])


# Generate the netlist for a bit array.
def makeNetlistForBA(size):
	lines = list()
	lines.append(".SUBCKT PSBA%d D %s Q VDD VSS" % (
		2**size,
		" ".join(["S%d GP%d GN%d" % (i,i,i) for i in range(2**size)])
	))
	for i in range(2**size):
		lines.append("X%d D S%d GP%d GN%d nL0Q%d VDD VSS PSBA1" % (
			i, i, i, i, i
		))
	if size % 2 == 0:
		outName = "nQ"
		lines.append("XINV nQ Q VDD VSS INV wp=660e-9 wn=480e-9")
	else:
		outName = "Q"
	for i in range(size):
		for n in range(2**(size-i-1)):
			lines.append("XL%dQ%d nL%dQ%d nL%dQ%d %s VDD VSS %s" % (
				i+1, n,
				i, n*2+0,
				i, n*2+1,
				("nL%dQ%d" % (i+1, n)) if i < size-1 else outName,
				"ND2" if i % 2 == 0 else "NR2"
			))
	lines.append(".ENDS")
	return "\n".join(lines)


# Generate the netlist for an address decoder.
def makeNetlistForAD(size):
	lines = list()
	lines.append(".SUBCKT PSAD%d CKP CKN %s %s %s VDD VSS" % (2**size,
		" ".join(["RA%d" % i for i in range(size)]),
		" ".join(["WA%d" % i for i in range(size)]),
		" ".join(["S%d GP%d GN%d" % (i,i,i) for i in range(2**size)])
	))
	for i in range(2**size):
		lines.append("XCKG%d CKP CKN nWE%d GP%d GN%d VDD VSS CKG " % (
			i, i, i, i,
		))

	if size > 3:
		radOutName = "S%d"
		wadOutName = "nWEB%d"
		invIn = "nWEB%d"
		invOut = "nWE%d"
	else:
		radOutName = "nRE%d"
		wadOutName = "nWE%d"
		invIn = "nRE%d"
		invOut = "S%d"

	lines.append("XRAD %s %s VDD VSS PSADOH%d" % (
		" ".join(["RA%d" % i for i in range(size)]),
		" ".join([radOutName % i for i in range(2**size)]),
		2**size
	))
	lines.append("XWAD %s %s VDD VSS PSADOH%d" % (
		" ".join(["WA%d" % i for i in range(size)]),
		" ".join([wadOutName % i for i in range(2**size)]),
		2**size
	))

	for i in range(2**size):
		lines.append("XINV%d %s %s VDD VSS INV wp=660e-9 wn=480e-9" % (i, invIn % i, invOut % i))

	lines.append(".ENDS")
	return makeNetlistForADOH(size) + "\n\n" + "\n".join(lines)


# Generate the netlist for the one-hot decoder used in address decoders.
def makeNetlistForADOH(size):
	lines = list()
	with open("%s/umc65/netlists/PSADOH%dR.cir" % (BASE, 2**size), "r") as f:
		lines.append(f.read())

	lines.append(".SUBCKT PSADOH%d %s %s VDD VSS" % (2**size,
		" ".join(["A%d" % i for i in range(size)]),
		" ".join(["Z%d" % i for i in range(2**size)])
	))
	N = 0
	for i in range(size):
		lines.append("XI%d A%d N%d VDD VSS INV wp=660e-9 wn=480e-9" % (N, i, i))
		N += 1
	N = 0
	for i in range(2**size):
		lines.append("X%d %s Z%d VDD VSS PSADOH%dR" % (N,
			" ".join([("A%d" if i & (1 << n) else "N%d") % n for n in range(size)]),
			i,
			2**size
		))
		N += 1
	lines.append(".ENDS")
	return "\n".join(lines)


def mainNetlist(argv):
	if len(argv) < 2 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	if argv[0].upper() == "TOP":
		if len(argv) < 3:
			sys.stderr.write("Top-level cell requires number of address lines and number of bits.\n")
			printUsage()
			sys.exit(1)
		print(makeNetlist(int(argv[1]), int(argv[2])))
	else:
		funcName = "makeNetlistFor" + argv[0].upper()
		if funcName not in globals():
			sys.stderr.write("Unknown component \"%s\"\n" % argv[0])
			printUsage()
			sys.exit(1)
		print(globals()[funcName](int(argv[1])))


def printUsage():
	sys.stderr.write("usage: potstill -h\n")
	sys.stderr.write("   or: potstill netlist COMPONENT SIZE\n")


def main(argv):
	if len(argv) == 0 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	mainName = "main" + argv[0].capitalize()
	if mainName not in globals():
		sys.stderr.write("Unknown command \"%s\"\n" % argv[0])
		printUsage()
		sys.exit(1)
	globals()[mainName](argv[1:])

if __name__ == "__main__":
	main(sys.argv[1:])
