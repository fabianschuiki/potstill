#!/usr/bin/env python3
# Copyright (c) 2016 Fabian Schuiki

import sys, os
import math
import argparse
import yaml
import subprocess
import src.macro
import src.pwrck
from src import nodeset
from src import netlist

BASE = sys.path[0]


def generateLayout(size, bits, outfile):

	# Read the configuration file for the technology.
	with open("%s/umc65/config.yml" % BASE, "r") as stream:
		config = yaml.load(stream)
	# print(config)

	cmds = list()

	# Load the input GDS data.
	for s in config["import"]["gds"]:
		cmds.append("load_gds \"%s/umc65/%s\";" % (BASE, s))

	num_bits_left   = int(bits/2)
	num_bits_right  = bits - num_bits_left
	num_addrs_left  = int(size/2)
	num_addrs_right = size - num_addrs_left

	G = config["track"]
	row_height = config["row-height"]*G
	bitarray_cell = "PSBT%d" % (2**size)

	bit_width = config["widths"]["bitarray"]*G
	rwckg_width = config["widths"]["rwckg"]*G
	addrdec_width = config["widths"]["addrdec"][2**size]*G
	rareg_width = config["widths"]["rareg"]*G

	# Assemble the root cell.
	x = 0
	cmds.append("cell \"PS%dX%d\" {" % (2**size, bits))
	cmds.append("set_size %g %g;" % (bits*bit_width+addrdec_width, (2**size + 1)*row_height))
	for i in range(num_bits_left):
		cmds.append("inst %s \"XBA%d\" {" % (bitarray_cell, i))
		cmds.append("set_orientation MX;")
		cmds.append("set_position %g 0;" % (x+bit_width))
		cmds.append("}")
		x += bit_width

	xral = x
	cmds.append("inst PSAD%d \"XAD\" {" % (2**size))
	cmds.append("set_position %g 0;" % x)
	cmds.append("}")
	x += addrdec_width
	xrar = x

	rwckg_x = x-rwckg_width
	rwckg_y = (2**size)*row_height
	cmds.append("inst PSRWCKG \"XRWCKG\" {")
	cmds.append("set_position %g %g;" % (rwckg_x, rwckg_y))
	cmds.append("}")

	for i in range(num_bits_right):
		cmds.append("inst %s \"XBA%d\" {" % (bitarray_cell, i+num_bits_left))
		cmds.append("set_position %g 0;" % x)
		cmds.append("}")
		x += bit_width

	x = xral - (num_addrs_left-1)*rareg_width
	for i in range(num_addrs_left):
		cmds.append("inst PSREGRA \"XRA%d\" {" % i)
		cmds.append("set_orientation R180;")
		cmds.append("set_position %g %g;" % (x, (2**size+2)*row_height))
		cmds.append("}")
		x += rareg_width

	x = xrar
	for i in range(num_addrs_right):
		cmds.append("inst PSREGRA \"XRA%d\" {" % (num_addrs_left+i))
		cmds.append("set_orientation MY;")
		cmds.append("set_position %g %g;" % (x, (2**size+2)*row_height))
		cmds.append("}")
		x += rareg_width

	# Add the power pins.
	pwr_pin_layer = int(config["pins"]["power"]["layer"])
	for i in range(0, 2**size+3, 2):
		cmds.append("add_gds_text %d %d %g %g VSS;" % (pwr_pin_layer, 0, xral+1*G, i*row_height))
	for i in range(1, 2**size+2, 2):
		cmds.append("add_gds_text %d %d %g %g VDD;" % (pwr_pin_layer, 0, xral+1*G, i*row_height))

	# Add the write address pins.
	addr_pin_layer = int(config["pins"]["addrdec"]["layer"])
	addr_vtracks = [int(x) for x in config["pins"]["addrdec"]["vtracks"][2**size]]
	N = 0
	for x in addr_vtracks:
		cmds.append("add_gds_text %d %d %g %g WA%d;" % (
			addr_pin_layer, 0,
			xral + (x+0.5)*G, (2**size)*row_height,
			N
		))
		N += 1

	# Add the global clock gate pins.
	rwckg_pins = config["pins"]["rwckg"]
	for (name,pin) in rwckg_pins.items():
		cmds.append("add_gds_text %d %d %g %g %s;" % (
			int(pin[2]), 0,
			rwckg_x + (int(pin[0])+0.5)*G, rwckg_y + int(pin[1])*G,
			name
		))

	# Add the bit array pins.
	bitarray_pins = config["pins"]["bitarray"]
	for (name,pin) in bitarray_pins.items():
		for i in range(num_bits_left):
			cmds.append("add_gds_text %d %d %g %g %s%d;" % (
				int(pin[2]), 0,
				(i+1)*bit_width - (int(pin[0])+0.5)*G, (2**size)*row_height + int(pin[1])*G,
				name, i
			))
		for i in range(num_bits_right):
			cmds.append("add_gds_text %d %d %g %g %s%d;" % (
				int(pin[2]), 0,
				xrar+i*bit_width + (int(pin[0])+0.5)*G, (2**size)*row_height + int(pin[1])*G,
				name, i + num_bits_left
			))

	cmds.append("}")

	# Create some GDS output from the cells generated above.
	cmds.append("gds \"PS%dX%d\" {" % (2**size, bits))
	# cmds.append("copy_cell_gds \"%s\";" % bitarray_cell)
	# cmds.append("copy_cell_gds \"PSAD%d\";" % (2**size))
	# for i in range(size):
	# 	cmds.append("copy_cell_gds \"PSBA%d\";" % (2**i))
	# for s in ["PSRMND", "PSRMNR"]:
	# 	cmds.append("copy_cell_gds \"%s\";" % s)
	cmds.append("make_gds_for_cell \"PS%dX%d\";" % (2**size, bits))
	cmds.append("write_gds \"%s\";" % outfile)
	cmds.append("}")

	print("\n".join(cmds))

	# Start phalanx and execute the commands.
	with subprocess.Popen(["phalanx"], stdin=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) as proc:
		(proc_out, proc_err) = proc.communicate(input="\n".join(cmds))
		sys.stderr.write(proc_err)
		if proc.returncode != 0:
			sys.stderr.write("Phalanx failed to generate GDS data.\n")
			sys.exit(1)


def mainNetlist(argv):
	if len(argv) < 2 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	if argv[0].upper() == "TOP":
		if len(argv) < 3:
			sys.stderr.write("Top-level cell requires number of address lines and number of bits.\n")
			printUsage()
			sys.exit(1)
		print(netlist.generate(int(argv[1]), int(argv[2])))
	else:
		funcName = "generate" + argv[0].upper()
		if not hasattr(netlist, funcName):
			sys.stderr.write("Unknown component \"%s\"\n" % argv[0])
			printUsage()
			sys.exit(1)
		print(getattr(netlist, funcName)(int(argv[1])))


def mainNodeset(argv):
	if len(argv) < 3:
		printUsage()
		sys.exit(1)
	nodeset.generate(argv[0], int(argv[1]), int(argv[2]))


def mainLayout(argv):
	if len(argv) < 3 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	generateLayout(int(argv[0]), int(argv[1]), argv[2])


def mainChar(argv):
	if len(argv) < 2 or argv[0] == "-h" or argv[0] == "--help":
		printCharUsage()
		sys.exit(1)

	num_addr = int(argv[0])
	num_bits = int(argv[1])
	macro = src.macro.Macro(num_addr, num_bits)

	mainCharMacro(macro, argv[2:])


def mainCharMacro(macro, argv):
	if len(argv) < 1:
		printCharUsage()
		sys.exit(1)
	mainName = "mainChar" + argv[0].capitalize()
	if mainName not in globals():
		sys.stderr.write("Unknown characterization command \"%s\"\n\n" % argv[0])
		printCharUsage()
		sys.exit(1)
	else:
		globals()[mainName](macro, argv[1:])


def mainCharPwrck(macro, argv):
	parser = argparse.ArgumentParser(description="Perform internal power characterization of the clock pin.")
	parser.add_argument("tslew", metavar="TSLEW", type=float, nargs="+", help="transition time of the clock input signal")
	parser.add_argument("-r", "--run", action="store_true")
	parser.add_argument("-i", "--inputs", action="store_true", dest="generateInputs", help="generate SPECTRE and OCEAN input files")
	parser.add_argument("-s", "--simulate", action="store_true", dest="runSpectre", help="run SPECTRE simulation")
	parser.add_argument("-a", "--analyze", action="store_true", dest="runOcean", help="run OCEAN analysis")
	parser.add_argument("--dump-spectre", action="store_true", dest="dumpSpectreInput")
	parser.add_argument("--dump-ocean", action="store_true", dest="dumpOceanInput")
	parser.add_argument("--vdd", metavar="VDD", type=float, default=1.2, help="supply voltage")
	args = parser.parse_args(argv)
	print(args)

	if len(args.tslew) == 1:
		pwrck = src.pwrck.Pwrck(macro, args.vdd, args.tslew[0])

		if args.dumpSpectreInput:
			print(pwrck.generateSpectreInput())
			sys.exit(0)
		if args.dumpOceanInput:
			print(pwrck.generateOceanInput())
			sys.exit(0)

		run = src.pwrck.PwrckRun(pwrck)
		print(run)
	else:
		run = src.pwrck.PwrckSweepRun(macro, args.vdd, args.tslew)
		print(run)

	if args.generateInputs:
		run.generateInputs()
	if args.runSpectre:
		run.runSpectre()
	if args.runOcean:
		run.runOcean()
	if args.run:
		run.run()

def printUsage():
	sys.stderr.write("usage: potstill -h\n")
	sys.stderr.write("   or: potstill netlist COMPONENT SIZE\n")
	sys.stderr.write("   or: potstill nodeset PREFIX NADDR NBITS\n")
	sys.stderr.write("   or: potstill layout ADDRWIDTH DATAWIDTH OUTFILE\n")

def printCharUsage():
	sys.stderr.write("usage: potstill char -h\n")
	sys.stderr.write("   or: potstill char AW DW COMMAND [OPTIONS]\n\n")
	sys.stderr.write("Where the most common commands are:\n")
	sys.stderr.write("   pwrck\n")

def main(argv):
	if len(argv) == 0 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	mainName = "main" + argv[0].capitalize()
	if mainName not in globals():
		cmd = "%s/bin/%s" % (BASE, argv[0])
		if os.path.exists(cmd):
			sys.exit(subprocess.call([cmd] + argv[1:]))
		else:
			sys.stderr.write("Unknown command \"%s\"\n" % argv[0])
			printUsage()
			sys.exit(1)
	else:
		globals()[mainName](argv[1:])

if __name__ == "__main__":
	main(sys.argv[1:])
