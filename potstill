#!/usr/bin/env python3
# Copyright (c) 2016 Fabian Schuiki

import sys, os
import math
import argparse
import yaml
import subprocess

BASE = sys.path[0]


def makeNetlist(size, bits):
	lines = list()
	lines.append(".SUBCKT PS%dX%d CK RE %s %s WE %s %s VDD VSS" % (
		2**size, bits,
		" ".join(["RA%d" % i for i in range(size)]),
		" ".join(["RD%d" % i for i in range(bits)]),
		" ".join(["WA%d" % i for i in range(size)]),
		" ".join(["WD%d" % i for i in range(bits)]),
	))

	netsRA = " ".join(["nRA%d" % i for i in range(size)])
	netsWA = " ".join(["WA%d" % i for i in range(size)])
	netsSGPGN = " ".join(["nS%d nGP%d nGN%d" % (i,i,i) for i in range(2**size)])

	# Add the root clock gates.
	lines.append("XRWCKG RE WE CK nRCKP nRCKN nWCKP nWCKN VDD VSS PSRWCKG")

	# # Add the clock buffer that provides the root CKP and CKN signals.
	# lines.append("XI0 CK nCKN VDD VSS INV PARAMS: wp=630e-9 wn=260e-9")
	# lines.append("XI1 nCKN nCKP VDD VSS INV PARAMS: wp=630e-9 wn=260e-9")

	# # Instantiate the two global clock gates.
	# lines.append("XWCKG WE nCKP nCKN nWCKP nWCKN VDD VSS CKG")
	# lines.append("XRCKG RE nCKP nCKN nRCKP nRCKN VDD VSS CKG")

	# Instantiate the address decoder.
	lines.append("XAD nWCKP nWCKN %s %s %s VDD VSS PSAD%d" % (
		netsRA, netsWA, netsSGPGN, 2**size
	))

	# Instantiate the write data registers.
	for i in range(bits):
		lines.append("XWDREG%d WD%d nWCKP nWCKN nWD%d iw%d VDD VSS PSREG" % (
			i, i, i, i
		))

	# Instantiate the read address registers.
	for i in range(size):
		lines.append("XRAREG%d RA%d nRCKP nRCKN nRA%d ir%d VDD VSS PSREG" % (
			i, i, i, i
		))

	# Instantiate the bit arrays.
	for i in range(bits):
		lines.append("XBA%d nWD%d %s RD%d VDD VSS PSBA%d" % (
			i, i, netsSGPGN, i, 2**size
		))

	lines.append(".ENDS")

	with open("%s/umc65/netlists/components.cir" % BASE, "r") as f:
		netlistPrefix = f.read()

	return "\n\n".join([
		netlistPrefix,
		makeNetlistForAD(size),
		makeNetlistForBA(size),
		"\n".join(lines)
	])


# Generate the netlist for a bit array.
def makeNetlistForBA(size):
	lines = list()
	lines.append(".SUBCKT PSBA%d D %s Q VDD VSS" % (
		2**size,
		" ".join(["S%d GP%d GN%d" % (i,i,i) for i in range(2**size)])
	))
	for i in range(2**size):
		lines.append("X%d D GP%d GN%d S%d nL0Q%d VDD VSS PSBA1" % (
			i, i, i, i, i
		))
	if size % 2 == 0:
		outName = "nQ"
		lines.append("XINV nQ Q VDD VSS PSRMINV")
	else:
		outName = "nQ"
		lines.append("XBUF nQ Q VDD VSS PSRMBUF")
	for i in range(size):
		for n in range(2**(size-i-1)):
			lines.append("XL%dQ%d nL%dQ%d nL%dQ%d %s VDD VSS %s" % (
				i+1, n,
				i, n*2+0,
				i, n*2+1,
				("nL%dQ%d" % (i+1, n)) if i < size-1 else outName,
				"PSRMND" if i % 2 == 0 else "PSRMNR"
			))
	lines.append(".ENDS")
	return "\n".join(lines)


# Generate the netlist for an address decoder.
def makeNetlistForAD(size):
	lines = list()
	lines.append(".SUBCKT PSAD%d CKP CKN %s %s %s VDD VSS" % (2**size,
		" ".join(["RA%d" % i for i in range(size)]),
		" ".join(["WA%d" % i for i in range(size)]),
		" ".join(["S%d GP%d GN%d" % (i,i,i) for i in range(2**size)])
	))
	for i in range(2**size):
		lines.append("XCKG%d nWE%d CKP CKN GP%d GN%d VDD VSS PSADCKG " % (
			i, i, i, i,
		))

	# if size > 3:
	# 	radOutName = "S%d"
	# 	wadOutName = "nWEB%d"
	# 	invIn = "nWEB%d"
	# 	invOut = "nWE%d"
	# else:
	# 	radOutName = "nRE%d"
	# 	wadOutName = "nWE%d"
	# 	invIn = "nRE%d"
	# 	invOut = "S%d"

	lines.append("XRAD %s %s VDD VSS PSADOH%d" % (
		" ".join(["RA%d" % i for i in range(size)]),
		" ".join(["S%d" % i for i in range(2**size)]),
		2**size
	))
	lines.append("XWAD %s %s VDD VSS PSADOH%d" % (
		" ".join(["WA%d" % i for i in range(size)]),
		" ".join(["nWE%d" % i for i in range(2**size)]),
		2**size
	))

	# for i in range(2**size):
	# 	lines.append("XINV%d %s %s VDD VSS PSADINV" % (i, invIn % i, invOut % i))

	lines.append(".ENDS")
	return makeNetlistForADOH(size) + "\n\n" + "\n".join(lines)


# Generate the netlist for the one-hot decoder used in address decoders.
def makeNetlistForADOH(size):
	lines = list()
	with open("%s/umc65/netlists/PSADOH%dR.cir" % (BASE, 2**size), "r") as f:
		lines.append(f.read())

	lines.append(".SUBCKT PSADOH%d %s %s VDD VSS" % (2**size,
		" ".join(["A%d" % i for i in range(size)]),
		" ".join(["Z%d" % i for i in range(2**size)])
	))
	N = 0
	for i in range(size):
		lines.append("XI%d A%d N%d VDD VSS PSADINV" % (N, i, i))
		N += 1
	N = 0
	actHiInputs = (size > 3)
	for i in range(2**size):
		lines.append("X%d %s Z%d VDD VSS PSADOH%dR" % (N,
			" ".join([("A%d" if (i if actHiInputs else ~i) & (1 << n) else "N%d") % n for n in range(size)]),
			i,
			2**size
		))
		N += 1
	lines.append(".ENDS")
	return "\n".join(lines)


def makeNodesetForADCKG(prefix, value):
	print(prefix+".X1.n1 %g" % value)


def makeNodesetForAD(prefix, num_addr):
	for i in range(2**num_addr):
		makeNodesetForADCKG(prefix+".XCKG%d" % i, 0)


def makeNodesetForREGLA(prefix, value):
	print(prefix+".n1 %g" % value)


def makeNodesetForREG(prefix, value):
	makeNodesetForREGLA(prefix+".XI0", value)
	makeNodesetForREGLA(prefix+".XI1", value)


def makeNodesetForBA1(prefix, value):
	print(prefix+".nFB", 1.2-value)


def makeNodesetForBT(prefix, num_addr, value):
	for i in range(2**num_addr):
		makeNodesetForBA1(prefix+".X%d" % i, value)


def makeNodeset(prefix, num_addr, num_bits):
	# Global clock gate.
	makeNodesetForADCKG(prefix+".XRWCKG.X0", 0)
	makeNodesetForADCKG(prefix+".XRWCKG.X1", 0)

	# Address decoder.
	makeNodesetForAD(prefix+".XAD", num_addr)

	# Write data and read address registers.
	for i in range(num_addr):
		makeNodesetForREG(prefix+".XRAREG%d" % i, 0)
	for i in range(num_bits):
		makeNodesetForREG(prefix+".XWDREG%d" % i, 0)

	# Memory columns.
	for i in range(num_bits):
		makeNodesetForBT(prefix+".XBA%d" % i, num_addr, 0)


def generateLayout(size, bits, outfile):

	# Read the configuration file for the technology.
	with open("%s/umc65/config.yml" % BASE, "r") as stream:
		config = yaml.load(stream)
	# print(config)

	cmds = list()

	# Load the input GDS data.
	for s in config["import"]["gds"]:
		cmds.append("load_gds \"%s/umc65/%s\";" % (BASE, s))

	num_bits_left   = int(bits/2)
	num_bits_right  = bits - num_bits_left
	num_addrs_left  = int(size/2)
	num_addrs_right = size - num_addrs_left

	G = config["track"]
	row_height = config["row-height"]*G
	bitarray_cell = "PSBT%d" % (2**size)

	bit_width = config["widths"]["bitarray"]*G
	rwckg_width = config["widths"]["rwckg"]*G
	addrdec_width = config["widths"]["addrdec"][2**size]*G
	rareg_width = config["widths"]["rareg"]*G

	# Assemble the root cell.
	x = 0
	cmds.append("cell \"PS%dX%d\" {" % (2**size, bits))
	cmds.append("set_size %g %g;" % (bits*bit_width+addrdec_width, (2**size + 1)*row_height))
	for i in range(num_bits_left):
		cmds.append("inst %s \"XBA%d\" {" % (bitarray_cell, i))
		cmds.append("set_orientation MX;")
		cmds.append("set_position %g 0;" % (x+bit_width))
		cmds.append("}")
		x += bit_width

	xral = x
	cmds.append("inst PSAD%d \"XAD\" {" % (2**size))
	cmds.append("set_position %g 0;" % x)
	cmds.append("}")
	x += addrdec_width
	xrar = x

	rwckg_x = x-rwckg_width
	rwckg_y = (2**size)*row_height
	cmds.append("inst PSRWCKG \"XRWCKG\" {")
	cmds.append("set_position %g %g;" % (rwckg_x, rwckg_y))
	cmds.append("}")

	for i in range(num_bits_right):
		cmds.append("inst %s \"XBA%d\" {" % (bitarray_cell, i+num_bits_left))
		cmds.append("set_position %g 0;" % x)
		cmds.append("}")
		x += bit_width

	x = xral - (num_addrs_left-1)*rareg_width
	for i in range(num_addrs_left):
		cmds.append("inst PSREGRA \"XRA%d\" {" % i)
		cmds.append("set_orientation R180;")
		cmds.append("set_position %g %g;" % (x, (2**size+2)*row_height))
		cmds.append("}")
		x += rareg_width

	x = xrar
	for i in range(num_addrs_right):
		cmds.append("inst PSREGRA \"XRA%d\" {" % (num_addrs_left+i))
		cmds.append("set_orientation MY;")
		cmds.append("set_position %g %g;" % (x, (2**size+2)*row_height))
		cmds.append("}")
		x += rareg_width

	# Add the power pins.
	pwr_pin_layer = int(config["pins"]["power"]["layer"])
	for i in range(0, 2**size+3, 2):
		cmds.append("add_gds_text %d %d %g %g VSS;" % (pwr_pin_layer, 0, xral+1*G, i*row_height))
	for i in range(1, 2**size+2, 2):
		cmds.append("add_gds_text %d %d %g %g VDD;" % (pwr_pin_layer, 0, xral+1*G, i*row_height))

	# Add the write address pins.
	addr_pin_layer = int(config["pins"]["addrdec"]["layer"])
	addr_vtracks = [int(x) for x in config["pins"]["addrdec"]["vtracks"][2**size]]
	N = 0
	for x in addr_vtracks:
		cmds.append("add_gds_text %d %d %g %g WA%d;" % (
			addr_pin_layer, 0,
			xral + (x+0.5)*G, (2**size)*row_height,
			N
		))
		N += 1

	# Add the global clock gate pins.
	rwckg_pins = config["pins"]["rwckg"]
	for (name,pin) in rwckg_pins.items():
		cmds.append("add_gds_text %d %d %g %g %s;" % (
			int(pin[2]), 0,
			rwckg_x + (int(pin[0])+0.5)*G, rwckg_y + int(pin[1])*G,
			name
		))

	# Add the bit array pins.
	bitarray_pins = config["pins"]["bitarray"]
	for (name,pin) in bitarray_pins.items():
		for i in range(num_bits_left):
			cmds.append("add_gds_text %d %d %g %g %s%d;" % (
				int(pin[2]), 0,
				(i+1)*bit_width - (int(pin[0])+0.5)*G, (2**size)*row_height + int(pin[1])*G,
				name, i
			))
		for i in range(num_bits_right):
			cmds.append("add_gds_text %d %d %g %g %s%d;" % (
				int(pin[2]), 0,
				xrar+i*bit_width + (int(pin[0])+0.5)*G, (2**size)*row_height + int(pin[1])*G,
				name, i + num_bits_left
			))

	cmds.append("}")

	# Create some GDS output from the cells generated above.
	cmds.append("gds \"PS%dX%d\" {" % (2**size, bits))
	# cmds.append("copy_cell_gds \"%s\";" % bitarray_cell)
	# cmds.append("copy_cell_gds \"PSAD%d\";" % (2**size))
	# for i in range(size):
	# 	cmds.append("copy_cell_gds \"PSBA%d\";" % (2**i))
	# for s in ["PSRMND", "PSRMNR"]:
	# 	cmds.append("copy_cell_gds \"%s\";" % s)
	cmds.append("make_gds_for_cell \"PS%dX%d\";" % (2**size, bits))
	cmds.append("write_gds \"%s\";" % outfile)
	cmds.append("}")

	print("\n".join(cmds))

	# Start phalanx and execute the commands.
	with subprocess.Popen(["phalanx"], stdin=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) as proc:
		(proc_out, proc_err) = proc.communicate(input="\n".join(cmds))
		sys.stderr.write(proc_err)
		if proc.returncode != 0:
			sys.stderr.write("Phalanx failed to generate GDS data.\n")
			sys.exit(1)


def mainNetlist(argv):
	if len(argv) < 2 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	if argv[0].upper() == "TOP":
		if len(argv) < 3:
			sys.stderr.write("Top-level cell requires number of address lines and number of bits.\n")
			printUsage()
			sys.exit(1)
		print(makeNetlist(int(argv[1]), int(argv[2])))
	else:
		funcName = "makeNetlistFor" + argv[0].upper()
		if funcName not in globals():
			sys.stderr.write("Unknown component \"%s\"\n" % argv[0])
			printUsage()
			sys.exit(1)
		print(globals()[funcName](int(argv[1])))


def mainNodeset(argv):
	if len(argv) < 3:
		printUsage()
		sys.exit(1)
	makeNodeset(argv[0], int(argv[1]), int(argv[2]))


def mainLayout(argv):
	if len(argv) < 3 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	generateLayout(int(argv[0]), int(argv[1]), argv[2])


def mainChar(argv):
	(outScs, outOcn) = makeScsForPowerChar(int(argv[0]), int(argv[1]))
	with open(argv[2]+".scs", "w") as f:
		f.write(outScs)
	with open(argv[2]+".ocn", "w") as f:
		f.write(outOcn)


def printUsage():
	sys.stderr.write("usage: potstill -h\n")
	sys.stderr.write("   or: potstill netlist COMPONENT SIZE\n")
	sys.stderr.write("   or: potstill nodeset PREFIX NADDR NBITS\n")
	sys.stderr.write("   or: potstill layout ADDRWIDTH DATAWIDTH OUTFILE\n")


def main(argv):
	if len(argv) == 0 or argv[0] == "-h" or argv[0] == "--help":
		printUsage()
		sys.exit(1)
	mainName = "main" + argv[0].capitalize()
	if mainName not in globals():
		cmd = "%s/bin/%s" % (BASE, argv[0])
		if os.path.exists(cmd):
			sys.exit(subprocess.call([cmd] + argv[1:]))
		else:
			sys.stderr.write("Unknown command \"%s\"\n" % argv[0])
			printUsage()
			sys.exit(1)
	else:
		globals()[mainName](argv[1:])

if __name__ == "__main__":
	main(sys.argv[1:])
